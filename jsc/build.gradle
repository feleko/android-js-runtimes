// Inherit group & version from root
//version '1.0.0'

buildscript {
    repositories {
        mavenCentral()
        google()
        maven { url "https://plugins.gradle.org/m2/" }
    }

    dependencies {
        classpath 'com.github.kezong:fat-aar:1.3.8'
    }
}


repositories {
    google()
    mavenCentral()
    maven {
        // Local Maven repo containing AAR with JSC library (single revision)
        url "$projectDir/../download-jsc/libs/250231.0.0/package/dist"
    }
}

apply plugin: 'com.kezong.fat-aar'

android {
    namespace "com.github.feleko.android_js_runtimes.jsc"

    // Pin an NDK version (pre-r23) so the legacy libc++ path used below exists and JitPack auto-downloads it.
    // If you want to change, prefer staying < 23 until bundleLibCppShared is updated for new layout.
    ndkVersion "21.4.7075529"

    packagingOptions {
        pickFirst '**/libjsc.so'
        pickFirst '**/libc++_shared.so'
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_11
        targetCompatibility JavaVersion.VERSION_11
    }

    buildTypes {
        release {
            // Include full debug symbols for native crash symbolication
            if (this.hasProperty('debugSymbolLevel')) {
                debugSymbolLevel 'FULL'
            }
        }
    }

    defaultConfig {
        externalNativeBuild {
            cmake {
                cppFlags ""
                arguments "-DANDROID_STL=c++_shared"//, "-DANDROID_ARM_NEON=TRUE"

            }

        }
    }

    // Ensure we can add generated jniLibs (libc++_shared.so) copied from NDK
    sourceSets {
        main {
            jniLibs.srcDirs += ["$buildDir/generated/jniLibs"]
        }
    }
}

// Copy libc++_shared.so from the local NDK into a generated jniLibs folder so that
// the produced fat AAR contains the C++ runtime required by libjsc.so. Without this
// the app can crash at runtime with: dlopen failed: library "libc++_shared.so" not found.
def abiList = ["armeabi-v7a", "arm64-v8a", "x86", "x86_64"]
def bundleLibCpp = (project.findProperty('jsc.bundleLibCpp') ?: 'true').toString().toBoolean()
def failIfNoLibCpp = (project.findProperty('jsc.failIfNoLibCpp') ?: 'false').toString().toBoolean()
tasks.register('bundleLibCppShared') {
    doLast {
        if (!bundleLibCpp) {
            logger.lifecycle("[jsc] Skipping libc++_shared bundling (jsc.bundleLibCpp=false)")
            return
        }
        File ndkDir = null
        try {
            ndkDir = android.ndkDirectory
        } catch (Throwable t) {
            logger.warn("[jsc] Unable to resolve android.ndkDirectory (${t.class.simpleName}: ${t.message}) -> skipping libc++ bundling")
            return
        }
    if (!ndkDir || !ndkDir.exists()) {
            // Try manual path using sdkDirectory + ndkVersion
            try {
                def sdkDir = android.sdkDirectory
                if (sdkDir && project.android.hasProperty('ndkVersion')) {
                    def manual = new File(sdkDir, "ndk/${project.android.ndkVersion}")
                    if (manual.exists()) ndkDir = manual
                }
            } catch (Throwable ignore) {}
            if (!ndkDir || !ndkDir.exists()) {
                def msg = "[jsc] NDK directory not found -> skipping libc++_shared.so bundling. Provide NDK, or disable (-Pjsc.bundleLibCpp=false)."
                if (failIfNoLibCpp) {
                    throw new GradleException(msg + " (failIfNoLibCpp=true)")
                } else {
                    logger.warn(msg)
                    return
                }
            }
        }
        int copied = 0
        def tripleMap = [
            'armeabi-v7a':'arm-linux-androideabi',
            'arm64-v8a':'aarch64-linux-android',
            'x86':'i686-linux-android',
            'x86_64':'x86_64-linux-android'
        ]
        abiList.each { abi ->
            List<File> candidates = []
            // Legacy (pre-r23)
            candidates << new File(ndkDir, "sources/cxx-stl/llvm-libc++/libs/${abi}/libc++_shared.so")
            // New (r23+) layouts
            def prebuiltRoot = new File(ndkDir, "toolchains/llvm/prebuilt")
            if (prebuiltRoot.exists()) {
                prebuiltRoot.eachDir { d ->
                    def f = new File(d, "sysroot/usr/lib/${tripleMap[abi]}/libc++_shared.so")
                    if (f.exists()) candidates << f
                }
            }
            def src = candidates.find { it.exists() }
            if (!src) {
                logger.warn("[jsc] libc++_shared.so not found for ABI ${abi} (checked legacy + new layouts). Skipping.")
            } else {
                def destDir = new File("$buildDir/generated/jniLibs/${abi}")
                destDir.mkdirs()
                project.copy { spec -> spec.from(src); spec.into(destDir) }
                copied++
                logger.lifecycle("[jsc] Copied libc++_shared.so for ${abi} from ${src}")
            }
        }
        if (copied == 0) {
            def msg2 = "[jsc] No libc++_shared.so copied for any ABI."
            if (failIfNoLibCpp) throw new GradleException(msg2) else logger.warn(msg2)
        }
    }
}

// Make sure native libs are prepared before packaging / merging.
preBuild.dependsOn tasks.named('bundleLibCppShared')

dependencies {
    // Single JSC revision (r250231) to avoid ABI conflicts and duplicate libjsc.so
    embed "org.webkit:android-jsc:r250231"
}

// Guard task: fail build if more than one android-jsc embed dependency is present
tasks.register('verifySingleJscEmbed') {
    doLast {
        def configsToCheck = configurations.matching { it.name in ['implementation','embed','api'] }
        def allRefs = []
        configsToCheck.each { cfg ->
            cfg.allDependencies.each { dep ->
                if (dep.group == 'org.webkit' && dep.name.startsWith('android-jsc')) {
                    allRefs << "${dep.group}:${dep.name}:${dep.version ?: 'unspecified'}"
                }
            }
        }
        def unique = allRefs.unique()
        if (unique.size() > 1) {
            throw new GradleException("[verifySingleJscEmbed] Multiple android-jsc variants detected: ${unique}")
        }
        logger.lifecycle("[verifySingleJscEmbed] OK (found: ${unique})")
    }
}

preBuild.dependsOn tasks.named('verifySingleJscEmbed')

// Ensure publication tasks wait for fat-aar reBundle output (removes implicit dependency warnings)
gradle.projectsEvaluated {
    def rebundle = tasks.findByName('reBundleAarRelease')
    if (rebundle) {
        ['publishReleasePublicationToMavenLocal', 'generateMetadataFileForReleasePublication', 'generatePomFileForReleasePublication'].each { n ->
            def t = tasks.findByName(n)
            if (t) t.dependsOn rebundle
        }
    }
}

// Verify that libc++_shared.so is actually packaged for required ABIs inside the produced AAR.
def requiredAbisProp = (project.findProperty('jsc.requiredAbis') ?: 'arm64-v8a,armeabi-v7a').toString()
def requiredAbis = requiredAbisProp.split(',').collect { it.trim() }.findAll { it }
tasks.register('verifyLibCppBundled') {
    dependsOn 'reBundleAarRelease'
    doLast {
        def aar = file("$buildDir/outputs/aar/jsc-release.aar")
        if (!aar.exists()) throw new GradleException("[verifyLibCppBundled] AAR not found: ${aar}")
        def zip = zipTree(aar)
        def missing = []
        requiredAbis.each { abi ->
            def hits = zip.matching { include "jni/${abi}/libc++_shared.so" }.files
            if (hits.empty) missing << abi
        }
        if (!missing.empty) {
            throw new GradleException("[verifyLibCppBundled] Missing libc++_shared.so for ABIs: ${missing} (required: ${requiredAbis})")
        }
        logger.lifecycle("[verifyLibCppBundled] OK (present for: ${requiredAbis})")
    }
}

// Publication tasks must also verify libc++ presence.
gradle.projectsEvaluated {
    ['publishReleasePublicationToMavenLocal','generateMetadataFileForReleasePublication'].each { n ->
        def t = tasks.findByName(n)
        if (t) t.dependsOn tasks.named('verifyLibCppBundled')
    }
}
